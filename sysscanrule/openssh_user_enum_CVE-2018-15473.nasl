include("compat.inc");

if (description)
{
  script_id(51799011);
  script_version("1.1");
  script_cvs_date("Date: 2018/08/22 13:59:42");

  script_cve_id("CVE-2018-15473");

  script_name(english:"OpenSSH user enumeration(CVE-2018-15473)");
  script_summary(english:"Checks OpenSSH version for the updated packages.");

  script_set_attribute(
    attribute:"synopsis",
    value:"The remote OpenSSH is missing a security update."
  );
  script_set_attribute(
    attribute:"description",
    value:
"It was discovered that there was a user enumeration vulnerability in
OpenSSH. A remote attacker couldtest whether a certain user exists on
a target server."
  );
  script_set_attribute(
    attribute:"see_also",
    value:"https://lists.debian.org/debian-lts-announce/2018/08/msg00022.html"
  );
  script_set_attribute(
    attribute:"see_also",
    value:"https://packages.debian.org/source/jessie/openssh"
  );
  script_set_attribute(attribute:"solution", value:"Upgrade OpenSSH to 7.7 or later version.");
  script_set_attribute(attribute:"risk_factor", value:"High");

  script_set_attribute(attribute:"plugin_type", value:"remote");

  script_set_attribute(attribute:"patch_publication_date", value:"2018/08/21");
  script_set_attribute(attribute:"plugin_publication_date", value:"2018/08/22");
  script_end_attributes();

  script_category(ACT_GATHER_INFO);
  script_copyright(english:"This script is Copyright (C) 2018 and is owned by WebRAY.");
  script_family(english:"Misc.");

  script_dependencies("ssh_detect.nasl");
  script_require_ports("Services/ssh", 22);

  exit(0);
}



include("global_settings.inc");
include("audit.inc");
include("ssh_func.inc");
include("misc_func.inc");

function my_ssh_login_public_key_only(pub, login)
{
  # Check status of _ssh_socket
  if(nasl_level() >= 6900 && !is_sock_open(_ssh_socket))
  {
    spad_log(message:"ssh_login_public_key_only: _ssh_socket is not open.");
    return FALSE;
  }

  # Use new SSH library if possible
  # if(using_ssh_wrappers())
    # return sshlib::ssh_login_public_key_only_wrapper(pub:pub, login:login, existing_socket:_ssh_socket);

  local_var buf, prot, ret, client_ver, server_version;

  init();

  client_ver = kb_ssh_client_ver();

  _ssh_current_user = login;

  # Exchange protocol version identification strings with the server.
  server_version = ssh_exchange_identification();
  if (!server_version)
  {
    set_ssh_error(msg: "GizaNE did not receive server's version.");
    return FALSE;
  }

  _ssh_server_version = server_version;

  # only ssh v2 is supported
  if (_ssh_protocol != 2)
  {
    set_ssh_error(msg: "GizaNE only supports SSH v2 for public key only authentication.");
    return FALSE;
  }

  # key exchange
  ret = ssh_kex2(server_version:server_version, nofingerprint:FALSE);
  if (ret != 0)
  {
    set_ssh_error(msg: "SSH key exchange failed.");
    return FALSE;
  }

  # Check if user authentication is supported.
  if (!ssh_req_svc("ssh-userauth"))
  {
    set_ssh_error(msg: "SSH user authentication is not supported.");
    return FALSE;
  }

  return my_ssh_userauth2_public_key_only(pub:pub, user:login);
}

function my_ssh_userauth2_public_key_only(pub, user)
{
  local_var code, key, payload, res;

  # Check that the required arguments are provided.
  if (!pub || !user)
  {
    set_ssh_error(msg: "User or public key is invalid.");
    return FALSE;
  }

  # Parse public key.
  key = ssh_parse_public_key_only(pub:pub);
  if (isnull(key))
  {
    set_ssh_error(msg:"Cannot parse public key.");
    return FALSE;
  }

  # Create key-agnostic portion of message.
  payload =
    putstring(buffer:user) +
    putstring(buffer:"ssh-connection") +
    putstring(buffer:"publickey") +
    # raw_int8(i:0) +
    putstring(buffer:key["type"]) +
    putstring(buffer:key["pub"]);



  # Send message to server.
  SSH_PACKET_LOG_SCRUB_STRING = key["pub"];
  send_ssh_packet(code:SSH_MSG_USERAUTH_REQUEST, payload:payload);
  SSH_PACKET_LOG_SCRUB_STRING = FALSE;

  # Read the server's response.
  res = recv_ssh_packet();
  #display("res len: " + len(res));
  #if(len(res) == 0)
  #	display("user is ok!\n");

  code = ord(res[0]);
  #display("code is: " + code);

  return code;
}

port = get_service(svc:'ssh', default:22, exit_on_fail:TRUE);

enable_ssh_wrappers();

unused_rsa_key = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCrhKssa/f/kxvlkDM8po52qo/X8CMa4dFngbYbcHOR7ljH5kGwDS44OE9TZAa51bk+quhW8GPVQbRYz2QB7nxBhYDzmMBBQJS9/LGPCCg9HoEABpKAIb3aG2ZXAHi9rdtRG4GyGi1xxzzxfoBUQjMN4H/PiF+1TOXIW6+G2oGQInHlnHN5I8FVJu3hpXwPiiPWtYWf6hYE7BQ0q2T/sFEyNk3nxYBIQs5kWIxoMVV9Nv1Djp2e2rv9g88N6cj1IGggHhoZ6tv/r+I9svGw7Rf+NP176LRGkCwLb+2FSGkP6jw+u3UCdlkaK/WIb1IANcGPUB/7oj+EiFaY1F3Mzkq5";

_ssh_socket = open_sock_tcp(port);
if (!_ssh_socket) audit(AUDIT_SOCK_FAIL, port);
ret = my_ssh_login_public_key_only(pub:unused_rsa_key, login:"root");
ssh_close_connection();

if(ret != 0) audit(AUDIT_LISTEN_NOT_VULN, "SSH server", port);

sleep(2);
_ssh_socket = open_sock_tcp(port);
if (!_ssh_socket) audit(AUDIT_SOCK_FAIL, port);
ret = my_ssh_login_public_key_only(pub:unused_rsa_key, login:"webray-scanner");
ssh_close_connection();

if(ret!=SSH_MSG_USERAUTH_BANNER && ret!=SSH_MSG_USERAUTH_FAILURE) audit(AUDIT_LISTEN_NOT_VULN, "SSH server", port);

if (report_verbosity > 0)
{
  report =
'GizaNE login ssh with id root and webray-scanner by public key, when sending a SSH_MSG_USERAUTH_REQUEST message which bool flag is removed,  we received a SSH_MSG_USERAUTH_BANNER message when use webray-scanner, and received nothing when use root\n' +
  security_hole(port:port, extra:report);
}
else security_hole(port);
